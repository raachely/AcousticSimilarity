function allNeuronCorrData = correlateDistanceToFiringRY(birdIDs, params, varargin)
% generates allNeuronCorrData
% RY modified from JMA version correlateDistanceToFiring.m
% commented more heavily; modified for aesthetics; commenting out various sections that I don't need for now

if nargin < 2 || isempty(params)
    params = defaultParams;
end
params = processArgs(params, varargin{:});

% in this script: try different analysis combining tutor distances and response
% strengths/responses per syllable
%dataDir = ['data' filesep birdID filesep];
if ~iscell(birdIDs)
    birdIDs = {birdIDs};
end
allNeuronCorrData = struct([]);
for bird = 1:numel(birdIDs) % bird loop
    birdRep = reportOnData(birdIDs{bird}, [], [], 'verbose',false);
    birdData = struct([]);
    for session = 1:numel(birdRep) % session loop
        sessionData = struct([]); %collection of cluster correlation data for all neurons & all syllable clusters in a session (compile neuronData into sessionData)
        
        %load neuron/acoustic measures for this session
        thisSession = birdRep(session).sessionID;
        hasData = all(findInManifest(birdRep(session).manifest,{'bestDistScore', 'neuronSyllableData'}));
        hasLabelData = all(findInManifest(birdRep(session).manifest,{'neuronSyllableData', ...
            'intraClusterDists', 'interClusterDists', 'acceptedLabels'}));
        if ~hasData
            fprintf('Missing data for session %s, continuing...\n', thisSession);
            continue;
        end
        
        % load the data collected from each neuron/syllable pair generated by writeNeuronStats
        nSData        = loadFromManifest(birdRep(session).manifest, 'neuronSyllableData');
        
        % load the different types of distances generated in compareTutorJuvenile and saveStereotypy
        distTo.tutor       = loadFromManifest(birdRep(session).manifest, 'bestDistScore');
        %distTo.consensus   = loadFromManifest(birdRep(ii).manifest, 'distToConsensus'); %RY commented out
        %distTo.central     = loadFromManifest(birdRep(ii).manifest, 'distToCentral'); %RY commented out
        distTo.intra       = loadFromManifest(birdRep(session).manifest, 'intraClusterDists');
        distTo.inter       = loadFromManifest(birdRep(session).manifest, 'interClusterDists');
        %distTo.humanMatch  = loadFromManifest(birdRep(ii).manifest, 'distToHumanMatch'); %RY commented uot
        
        nNeurons  = size(nSData, 1);
        nClusters = size(nSData, 2)-1; % not the "unlabeled" clusters
        
        % Bonferroni correction for neurons that fire significantly to a given syllable
        correctedP = 0.05/(nNeurons * nClusters);
        %nR = floor(sqrt(nClusters)); %RY commented out - unused
        %nC = ceil(nClusters/nR); %RY commented out - unused
        
        fprintf('Reading data for session %s, %d neurons, %d clusters...\n', thisSession, nNeurons, nClusters);
        
        %% For this session, loop through each neuron's response for each juv syllable cluster
        for neuron = 1:nNeurons  % neuron loop
            neuronData = struct([]); %collection of cluster correlation data for a given neuron & all syllable clusters (compile corrData into neuronData)
            dPs = fieldnames(distTo); %different distance metrics (tutor, intra, & inter); easier for looping
            
            hf = zeros(1,numel(dPs)); %figure handles
            hasAnyPlot = false(1,numel(dPs)); % whether a plot was created - for titling/init purposes
            
            for cluster = 1:nClusters % syllable cluster loop
                thisNeuronEntry = nSData(neuron,cluster);
                
                % take out the neuron/syll pair entries for the unlabeledsyllable
                if isnan(thisNeuronEntry.syllID)
                    continue;
                end
                
                % corrData stores the correlation data between a single neuron and a single corresponding syllable cluster
                % copy over basic calc info
                corrData.syllID         = thisNeuronEntry.syllID;
%                corrData.isCore         = thisNeuronEntry.isCore;
%                corrData.isMUA          = thisNeuronEntry.isMUA;
%                corrData.isPlastic      = thisNeuronEntry.isPlastic;
                corrData.nSylls         = numel(thisNeuronEntry.syllIndex);
                corrData.pResponse      = thisNeuronEntry.p_ttest;
                corrData.burstFraction  = thisNeuronEntry.burstFraction';
                corrData.avgResponse    = thisNeuronEntry.FR_syllable - thisNeuronEntry.FR_baseline; %average firing rate during syllables in clusterX - average baseline
                corrData.FRSyll         = thisNeuronEntry.rawRates(1,:); %
                corrData.FRBase         = thisNeuronEntry.rawRates(2,:);
                
                corrData.RSAll = corrData.FRSyll - corrData.FRBase; %row of response strengths for this neuron during renditions of syllables in clusterX (difference scores; not standardized)
                
                % is the neuron excited or inhibited during this syllable?
                corrData.isExcited   = (thisNeuronEntry.FR_syllable > thisNeuronEntry.FR_baseline);
                
                % does the neuron respond significantly above/baseline for this cluster?
                corrData.sigResponse = (thisNeuronEntry.p_ttest < correctedP);
                
                %% Correlation between FR & tutor/intra/inter distances
                %pre-allocating structure fields w/ NaNs; RY re-wrote to exclude quartile stuff
%                 for ll = 1:numel(dPs)
%                     [corrData.([dPs{ll} 'DistanceR2']), corrData.([dPs{ll} 'Distance_p' ]), ...
%                         corrData.([dPs{ll} '_farMeanRS']), corrData.([dPs{ll} '_nearMeanRS']), ...
%                         corrData.([dPs{ll} '_farSEMRS' ]), corrData.([dPs{ll} '_nearSEMRS' ]), ...
%                         corrData.([dPs{ll} '_farZ' ]), corrData.([dPs{ll} '_nearZ' ]), ...
%                         corrData.([dPs{ll} '_farNear_tTestP']), corrData.([dPs{ll} '_farNear_tStat']), ...
%                         corrData.([dPs{ll} '_dRSnorm']),corrData.([dPs{ll} '_farCov']),corrData.([dPs{ll} '_nearCov']),...
%                         corrData.('RSAll'),corrData.([dPs{ll} '_DistanceAll']),...
%                         corrData.('FRSyll'),corrData.('FRBase'),corrData.('burstFraction'),corrData.([dPs{ll} '_farCV']),...
%                         corrData.([dPs{ll} '_nearCV'])] = ...
%                         deal(NaN);
%                 end
                for ll = 1:numel(dPs)
                        [corrData.([dPs{ll} 'DistanceR2']),...
                         corrData.([dPs{ll} 'Distance_p' ]),... 
                         corrData.([dPs{ll} '_DistanceAll'])] = deal(NaN);
                end
                              
                if hasLabelData
                    % loop through these distance prefixes declared in distTo (tutor, intra, & inter)
                    for ll = 1:numel(dPs)
                        % make sure it's not all missing data
                        if all(isnan(distTo.(dPs{ll})(thisNeuronEntry.syllIndex)))
                            warning('No nonNaN values for distances to %s available for cluster %d', dPs{ll}, thisNeuronEntry.syllID);
                            continue;
                        end
                        
                        corrData.([dPs{ll} '_DistanceAll']) = (distTo.(dPs{ll})(thisNeuronEntry.syllIndex)); %JMA added; copy over/store distance measures in corrData structure
                        
                        % get correlation of response strength to distance metric
                        [corrData.([dPs{ll} 'DistanceR2']), corrData.([dPs{ll} 'Distance_p'])] = ...
                            neuralCorr(thisNeuronEntry, distTo.(dPs{ll}));
                        
                        
                        %                         %RY commented out; leaving out quartile stuff for now, plus not sure if it's correct here
                        %                         %"All of the quartile stuff is actually done in plotNeuronCorrData where we specifiy cluster quality to include etc; "
                        %
                        %                         % get response strengths and SEMS for syllables that match top 25% and bottom 25% of distance metric
                        %                         %Actually we need FR and SD not RS so JMA changed this
                        %                         [corrData.([dPs{ll} '_farMeanRS']), corrData.([dPs{ll} '_nearMeanRS']), ...
                        %                             corrData.([dPs{ll} '_farSEMRS' ]), corrData.([dPs{ll} '_nearSEMRS' ]), nQuartile, ...
                        %                             corrData.([dPs{ll} '_farNear_tTestP']), corrData.([dPs{ll} '_farNear_tStat']),...
                        %                             corrData.([dPs{ll} '_farCov']),corrData.([dPs{ll} '_nearCov']),...
                        %                             corrData.([dPs{ll} '_farCV']), corrData.([dPs{ll} '_nearCV'])] = ...
                        %                             neuralQuartileFR(thisNeuronEntry, distTo.(dPs{ll}));
                        %
                        %                         %unused?
                        % %                         covRS = cov(RS_syll, RS_base);
                        % %                         if numel(covRS) > 1
                        % %                             covRS = covRS(2,1);
                        % %                         end
                        %
                        %                         %SE_syllBaseFiring = sqrt(var(RS_syll) + var(RS_base) - 2 * covRS) / sqrt(sum(corrData.nSylls));
                        %                         %corrData.([dPs{ll} '_farZ']) = (corrData.([dPs{ll} '_farMeanRS']) - corrData.avgResponse)/ SE_syllBaseFiring;
                        %                         %corrData.([dPs{ll} '_nearZ']) = (corrData.([dPs{ll} '_nearMeanRS']) - corrData.avgResponse)/ SE_syllBaseFiring;
                        %                         %JMA changed from this because not the z-score I wanted, rather z-score of near/far from baseline
                        %                         corrData.([dPs{ll} '_farZ']) =  ((corrData.([dPs{ll} '_farMeanRS'])  - mean(RS_base))* sqrt(nQuartile(1)))/ farVar; %JMA added
                        %                         corrData.([dPs{ll} '_nearZ']) = ((corrData.([dPs{ll} '_nearMeanRS']) - mean(RS_base))* sqrt(nQuartile(1)))/ nearVar; %JMA added
                        %                         farVar = sqrt(corrData.([dPs{ll} '_farSEMRS']) + var(RS_base) - 2* corrData.([dPs{ll} '_farCov'])); %JMA added
                        %                         nearVar = sqrt(corrData.([dPs{ll} '_nearSEMRS']) + var(RS_base) - 2* corrData.([dPs{ll} '_nearCov'])); %JMA added
                        %
                        %                         %dRS = corrData.([dPs{ll} '_nearMeanRS']) - corrData.([dPs{ll} '_farMeanRS']);
                        %                         corrData.([dPs{ll} '_dRSnorm']) = corrData.([dPs{ll} '_nearZ']) - corrData.([dPs{ll} '_farZ']);
                        %                         %corrData.([dPs{ll} '_dRSnorm']) = sqrt(sum(nQuartile)) * dRS/sqrt(var(RS_syll) + var(RS_base) - 2 * covRS);
                        
                        % if params.plot && corrData.sigResponse %JMA removed .sigResponse and put corrData.isMUA == 0
                        if params.plot && corrData.isMUA == 0
                            if hasAnyPlot(ll)
                                figure(hf(ll)) %<- figure for the distance metric
                            else
                                hf(ll) = figure;
                            end
                            
                            % subplot(nR, nC, kk); %<- subplot for the syllable number --this doesn't really work out --JMA
                            neuralCorrPlot(thisNeuronEntry, distTo.(dPs{ll}));
                            ylabel(sprintf('%s distance', dPs{ll}));
                            xlabel(sprintf('RS, \\DeltaRS = %0.2f, \\DeltaRS_n = %0.2f', (corrData.([dPs{ll} '_farMeanRS'])- corrData.([dPs{ll} '_nearMeanRS'])), corrData.([dPs{ll} '_dRSnorm']))); %JMA changed DeltaRS value from dRS which wasn't defined
                            
                            % get/plot the low and high quartile values
                            iqDists = prctile(distTo.(dPs{ll})(thisNeuronEntry.syllIndex), [25 75]);
                            hold on;
                            plot(xlim, iqDists([1 1]), 'b--', xlim, iqDists([2 2]), 'g--');
                            hold off;
                            
                            title(sprintf('session %s, neur %d, clust %d', ...
                                thisSession, neuron, thisNeuronEntry.syllID),'Interpreter','none');
                            hasAnyPlot(ll) = true;
                        end
                    end
                else
                    fprintf('Data missing for session %s, neuron %d, cluster %d...\n',...
                        thisSession, neuron, thisNeuronEntry.syllID);
                end
                neuronData = [neuronData; corrData];
                clear corrData;
            end % end cluster loop
            fprintf('Finished compiling neuron %d for this session %s...\n', neuron, thisSession);
            [neuronData.unitNum] = deal(neuron);
            sessionData = [sessionData; neuronData];
            
            for ll = 1:numel(dPs)
                if hasAnyPlot(ll)
                    figure(hf(ll))
                    set(gcf,'Units','normalized','Position',[0 0 1 1]);
                    
                    figDir = 'figures/distanceCorrelations/';
                    fileName = [figDir thisSession '-neuron-' num2str(neuron) '-' dPs{ll} '.jpg'];
                    %fprintf('Saving figure %s...\n',fileName);
                    saveCurrFigure(fileName);
                    close;
                end
            end
            
        end % end neuron loop
        fprintf('Finished compiling for this session %s...\n', thisSession);
        [sessionData.sessionID] = deal(thisSession);
        birdData = [birdData; sessionData];
    end % end session loop
    fprintf('Finished compiling for this bird %s...\n', birdIDs{bird});
    [sessionData.birdID] = deal(birdIDs{bird});
    allNeuronCorrData = [allNeuronCorrData; birdData];
end % end bird loop
save('data/allNeuronCorrelations.mat', 'allNeuronCorrData');
end

function neuralCorrPlot(neuronEntry, dist)
% can't match the NaN/everything else cluster
xxdat = -diff(neuronEntry.rawRates,1,1); % response strengths
yydat = dist(neuronEntry.syllIndex);
if size(xxdat,2) > 1, xxdat = xxdat'; end;
if size(yydat,2) > 1, yydat = yydat'; end;
if numel(yydat) == 1
    linfit = NaN(1,2);
    fitStats = NaN(1,3);
else
    [linfit, ~,~,~, fitStats] = regress(yydat, [ones(numel(xxdat),1) xxdat]);
end
plot(xxdat, yydat, 'k.', 'HandleVisibility', 'off');
hold on;
plot(xxdat, linfit(1) + xxdat * linfit(2), '--','Color',[1 0 0]);
legend(sprintf('r^2 = %0.3g, F = %0.3g, p = %0.3g\n',...
    fitStats(1), fitStats(2),fitStats(3)));
xlabel('Response Strength'); ylabel('Matched distance');
end

% load matchfile
%{
    matchFile = [dataDir 'matchToTutor-age' num2str(getAgeOfSession(thisSession)) '.mat'];
    if exist(matchFile, 'file') == 2
        load(matchFile, 'typeMatch'); % this is generated by assignClusterToTutor
        %% distance just to matched tutor syllable
        distToAllSylls = loadFromManifest(birdRep(ii).manifest,'distToTutor');
        typeMatchIndex = cellfun(@(x) x - 'a' + 1, typeMatch);
        for jj = 1:nNeurons
            figure('Name',[thisSession ' - tutor distance']);
            for kk = 1:nClusters
                % pair of neuron and cluster
                thisPair = nSData(jj,kk);
                
                % only significant neurons
                if thisPair.p_ttest >= correctedP
                    continue;
                end
                % can't match the NaN/everything else cluster
                if isnan(thisPair.syllID)
                    continue;
                end
                xxdat = diff(thisPair.rawRates,1); % response strengths
                yydat = distToAllSylls(typeMatchIndex(kk), thisPair.syllIndex);
                
                % get the linear regression
                subplot(nR, nC, kk);
                if numel(yydat) == 1
                    linfit = NaN(1,2);
                    fitStats = NaN(1,3);
                else
                    [linfit, ~,~,~, fitStats] = regress(yydat', [ones(numel(xxdat),1) xxdat']);
                end
                plot(xxdat, yydat, 'k.', 'HandleVisibility', 'off');
                hold on;
                plot(xxdat, linfit(1) + xxdat * linfit(2), '--','Color',[1 0 0]);
                legend(sprintf('r^2 = %0.3g, F = %0.3g, p = %0.3g\n',...
                    fitStats(1), fitStats(2),fitStats(3)));
                xlabel('Response Strength'); ylabel('Matched distance');
                title(sprintf('session %s, neuron %d, cluster %d', thisSession, jj, thisPair.syllID),'Interpreter','none');
            end
        end
    else
        % there's no match file
        fprintf('No match file for bird %s found...\n', birdID);
    end
%}


function [corr_val, corr_p] = neuralCorr(neuronEntry, distanceMetric)
% neuronEntry describes the firing rates of neuron and matching cluster
% distanceMetric is the distances of some type for all
% syllables within a session

% only significant neurons
xxdat = -diff(neuronEntry.rawRates,1); % response strengths just as differences between baseline & syllable
if size(xxdat,2) > 1, xxdat = xxdat'; end; %convert to column if not already
yydat = distanceMetric(neuronEntry.syllIndex); %get juv-tut distances for only syllables from the cluster in question
if size(yydat,2) > 1, yydat = yydat'; end; %convert to column if not already

% get the linear regression

% can't regress if only one syllable exists, or all the syllables have the
% saem response strengths
if numel(yydat) == 1 || all(xxdat == xxdat(1))
    corr_val = 0; corr_p = 1; return;
else
    % convert rank-deficiency to an error
    s = warning('error','stats:regress:RankDefDesignMat');
    try
        [linfit, ~,~,~, fitStats] = regress(yydat, [ones(numel(xxdat),1) xxdat]);
    catch err
        if strcmp(err.identifier,'stats:regress:RankDefDesignMat');
            keyboard
        else
            rethrow(err);
        end
    end
    warning(s)
    corr_val = fitStats(1);
    corr_p = fitStats(3);
    % F_value is fitStats(2)
end
end

function [fq_meanRS, nq_meanRS, fq_SEMRS, nq_SEMRS, nQuartile, pVal, tVal,fcovar, ncovar, farCV, nearCV] = neuralQuartileFR(neuronEntry, distanceMetric)
% neuronEntry describes the firing rates of neuron and matching cluster
% distanceMetric is the distances of some type for all
% syllables within a session

%JMA changed to get FRs not RS to generate z-scores
% fq describes the far quartile of a syllable cluster (relative to
% some distance)
% nq describes the near quartile

% response strengths are differences between the firing between events (first row)
% and matched baselines (second row)
% RSs = -diff(neuronEntry.rawRates,1);
RSs = neuronEntry.rawRates(1,:);
Bas = neuronEntry.rawRates(2,:); %JMA added
% distances are selected only for the syllable cluster this neuronEntry
% refers to
dists = distanceMetric(neuronEntry.syllIndex);

% only one syllable? this shouldn't happen

if numel(distanceMetric) == 1,
    fq_meanRS=RSs; nq_meanRS=RSs; fq_SEMRS=NaN; nq_SEMRS=NaN; nQuartile = [0 0]; return;
end

% get the low and high quartile values
iqDists = prctile(dists, [25 75]);
near_quartileRS = RSs(dists < iqDists(1)); nQuartile(1) = numel(near_quartileRS);
far_quartileRS  = RSs(dists > iqDists(2)); nQuartile(2) = numel( far_quartileRS);
% nq_meanRS = mean(near_quartileRS); nq_SEMRS = std(near_quartileRS) / sqrt(nQuartile(1) - 1);
% fq_meanRS = mean( far_quartileRS); fq_SEMRS = std( far_quartileRS) / sqrt(nQuartile(2) - 1);
nq_meanRS = mean(near_quartileRS); nq_SEMRS = var(near_quartileRS); %JMA changed to get variance to generate z-score
fq_meanRS = mean( far_quartileRS); fq_SEMRS = var( far_quartileRS);
[~, pVal, ~, tValStruct] = ttest2(near_quartileRS, far_quartileRS);
tVal = tValStruct.tstat;
fcovar = cov(RSs(dists > iqDists(2)),Bas(dists > iqDists(2)));if numel(fcovar) > 1, fcovar = fcovar(2,1); end; %JMA added
ncovar = cov(RSs(dists < iqDists(1)),Bas(dists < iqDists(1)));if numel(ncovar) > 1, ncovar = ncovar(2,1); end; %JMA added
farCV = std(far_quartileRS)/fq_meanRS; %JMA added
nearCV = std(near_quartileRS)/fq_meanRS; %JMA added
end